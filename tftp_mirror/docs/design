protocol:

       status code                       client                                      server
-------------------------|---------------------------------------------------|--------------------------------------------
| 0:filename             | sends the file name                               | gets filename & sends file size           |
| 1:filename:i,n:        | sends offset & bytes                              | gets file from offset to num-bytes        |
| 2:filename:i,n:string  | same as 1, but reads only the string up to n bytes| sends the string                          |
--------------------------------------------------------------------------------------------------------------------------

overview:
0. client looks thru the server-info.txt and pings each one to see whos up.
1. client requests a 0:filename
2. server sends filename file size(0:filesize). if file doesn't exist it sends 0:0 for filesize of zero.
3. client divides filesize by the number of chunks it wants
4. each chunk is responsible for a offset and bytes to read.
5. for each chunk a new thread is created.
6. for each server up a thread will be assigned to one in a circular queue fashion.
7. each thread sends a request in such 1:filename:offset,bytes:
8. server respondes back with the 2:filename:offset,bytes_to_read:string
9. each thread will add the string to a queue with the offset specification, so later on it can be sorted
10. once the queue is sorted it will write it to a file.

each queue has an offset,bytes and filename property. Along with it the nodes have the same property and its because if the data is too big it will be broken down apart further and will be used to determine the order based on the offsets.

if it happens that one server is up and we need n chunks then 5 threads will be created with the same ip and port.
to avoid data curruption each time the same server comes to run as a thread a new queue will be assigned for the offset and bytes to read.
one offset and bytes to read might be too be big, thats why I'm using a queue for each offset and bytes to read.

to avoid duplicate data, I will check in the queue which is responsible for the offset,bytes to see if there is a node which that specifications already in it.
